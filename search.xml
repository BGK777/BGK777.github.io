<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>node.js关于版本遇到的问题</title>
      <link href="/2023/05/08/node-js-guan-yu-ban-ben-yu-dao-de-wen-ti/"/>
      <url>/2023/05/08/node-js-guan-yu-ban-ben-yu-dao-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><p>在运行npm bulid/npm run dev的时候出现报错”[ERR_OSSL_EVP_UNSUPPORTED]”，如下图：</p><p><img src="/.io//9de7ed9fdbae443f9518c625fe3c56a7~tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp" alt="问题"></p><hr><h1 id="问题原因："><a href="#问题原因：" class="headerlink" title="问题原因："></a>问题原因：</h1><p>原因是node v17中的OpenSSL3.0对允许算法和密钥大小增加了严格的限制，node v16之前没有问题</p><hr><h1 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h1><p>方法一： 终端运行如下代码（命令行输入，但是每次启动项目都得执行手动一次）：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">export <span class="token constant">NODE_OPTIONS</span><span class="token operator">=</span><span class="token operator">--</span>openssl<span class="token operator">-</span>legacy<span class="token operator">-</span>provider<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方法二： 在配置页面将<code>export NODE_OPTIONS=--openssl-legacy-provider</code>加入指令中，如下图所示（可以做到一劳永逸）：</p><p><img src="/.io//b76e050ac0d24d65b566cf03d595689b~tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp" alt="解决图片"></p>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node.js关于版本遇到的问题</title>
      <link href="/2023/05/06/node.js-guan-yu-ban-ben-yu-dao-de-wen-ti-x/"/>
      <url>/2023/05/06/node.js-guan-yu-ban-ben-yu-dao-de-wen-ti-x/</url>
      
        <content type="html"><![CDATA[<h1>问题：</h1><p>在运行npm bulid/npm run dev的时候出现报错”[ERR_OSSL_EVP_UNSUPPORTED]”，如下图：</p><p><img src="/2023/05/06/node/BGKblog\blog\source_posts\图片合集\9de7ed9fdbae443f9518c625fe3c56a7~tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp" alt="问题"></p><hr><h1 id="问题原因："><a href="#问题原因：" class="headerlink" title="问题原因："></a>问题原因：</h1><p>原因是node v17中的OpenSSL3.0对允许算法和密钥大小增加了严格的限制，node v16之前没有问题</p><hr><h1 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h1><p>方法一： 终端运行如下代码（命令行输入，但是每次启动项目都得执行手动一次）：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">export <span class="token constant">NODE_OPTIONS</span><span class="token operator">=</span><span class="token operator">--</span>openssl<span class="token operator">-</span>legacy<span class="token operator">-</span>provider<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方法二： 在配置页面将<code>export NODE_OPTIONS=--openssl-legacy-provider</code>加入指令中，如下图所示（可以做到一劳永逸）：</p><p><img src="/2023/05/06/node/BGKblog\blog\source_posts\图片合集\b76e050ac0d24d65b566cf03d595689b~tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp" alt="解决图片"></p>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合</title>
      <link href="/2023/05/04/ji-he/"/>
      <url>/2023/05/04/ji-he/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Java集合框架概述"><a href="#1-Java集合框架概述" class="headerlink" title="1.Java集合框架概述"></a>1.Java集合框架概述</h1><p>1.集合、数组都是对多个数据进行存储操作的结构，简称<strong>Java容器</strong>。</p><p>  说明：此时的存储，主要指的是<strong>内存层面的存储</strong>，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中）</p><p>2.关于数组</p><p>  2.1 数组在存储多个数据方面的特点：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">1.</span> 一旦初始化以后，其长度就确定了。<span class="token number">2.</span> 数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。比如：<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1<span class="token punctuation">;</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>  2.2 数组在存储多个数据方面的缺点：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">1.</span> 一旦初始化以后，其长度就不可修改。<span class="token number">2.</span> 数组中<span class="token operator">*</span><span class="token operator">*</span>提供的方法非常有限<span class="token operator">*</span><span class="token operator">*</span>，对<span class="token operator">*</span><span class="token operator">*</span>于添加、删除、插入数据等操作，非常不便，同时效率不高。<span class="token operator">*</span><span class="token operator">*</span><span class="token number">3.</span> 获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用<span class="token number">4.</span> 数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.集合框架</p><p>|—-Collection接口：<strong>单列集合，用来存储一个一个的对象</strong></p><p>  |—-<strong>List</strong>接口：<strong>存储有序的、可重复的数据</strong>。  –&gt;“动态”数组</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token class-name">ArrayList</span>、<span class="token class-name">LinkedList</span>、<span class="token class-name">Vector</span>    （实现类）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  |—-<strong>Set</strong>接口：<strong>存储无序的、不可重复的数据</strong>   –&gt;高中讲的“集合”</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token class-name">HashSet</span>、<span class="token class-name">LinkedHashSet</span>、<span class="token class-name">TreeSet</span>    （实现类）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>|—-Map接口：<strong>双列集合，用来存储一对(key - value)一对的数据   –&gt;高中函数：y = f(x)</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token class-name">HashMap</span>、<span class="token class-name">LinkedHashMap</span>、<span class="token class-name">TreeMap</span>、<span class="token class-name">Hashtable</span>、<span class="token class-name">Properties</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>图示：Collection接口继承树</strong></p><p><img src="/.io//image.png" alt="image.png"></p><p><strong>图示：Map接口继承树</strong></p><h1 id="2-Collection接口"><a href="#2-Collection接口" class="headerlink" title="2.Collection接口"></a>2.Collection接口</h1><h2 id="1-Collection接口中的方法的使用"><a href="#1-Collection接口中的方法的使用" class="headerlink" title="1.Collection接口中的方法的使用"></a>1.Collection接口中的方法的使用</h2><p>1、添加 </p><p>   <strong>add(Object obj)</strong> </p><p>   <strong>addAll(Collection coll)</strong> </p><p>2、获取有效元素的个数 </p><p>   <strong>int size()</strong> </p><p>3、清空集合 </p><p>   <strong>void clear()</strong> </p><p>4、是否是空集合 </p><p>   <strong>boolean isEmpty()</strong> </p><p>5、是否包含某个元素 </p><p>   **boolean contains(Object obj)**：是通过元素的equals方法来判断是否 是同一个对象 </p><p>   **boolean containsAll(Collection c)**：也是调用元素的equals方法来比 较的。拿两个集合的元素挨个比较。</p><p>6、删除 </p><p>   <strong>boolean remove(Object obj)</strong> ：通过元素的equals方法判断是否是 要删除的那个元素。只会删除找到的第一个元素 </p><p>  ![image.png](图片合集/image 1.png)</p><p>   **boolean removeAll(Collection coll)**：取当前集合的差集 </p><p>7、取两个集合的交集 </p><p>   **boolean retainAll(Collection c)**：把交集的结果存在当前集合中，不 影响c </p><p>8、集合是否相等 </p><p>   <strong>boolean equals(Object obj)</strong> </p><p>9、转成对象数组 </p><p>   <strong>Object[] toArray()</strong> </p><p>10、获取集合对象的哈希值 </p><p>   <strong>hashCode()</strong> </p><p>11、遍历 </p><p>   **iterator()**：返回迭代器对象，用于集合遍历</p><ul><li><p>代码测试</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">  @Test    public void test1(){        Collection coll = new ArrayList();          //add(Object e):将元素e添加到集合coll中        coll.add("AA");        coll.add("BB");        coll.add(123);//自动装箱        coll.add(new Date());          //size():获取添加的元素的个数        System.out.println(coll.size());//4          //addAll(Collection coll1):将coll1集合中的元素添加到当前的集合中        Collection coll1 = new ArrayList();        coll1.add(456);        coll1.add("CC");        coll.addAll(coll1);          System.out.println(coll.size());//6        System.out.println(coll);          //clear():清空集合元素        coll.clear();          //isEmpty():判断当前集合是否为空        System.out.println(coll.isEmpty());  public void test1(){        Collection coll = new ArrayList();        coll.add(123);        coll.add(456);  //        Person p = new Person("Jerry",20);  //        coll.add(p);        coll.add(new Person("Jerry",20));        coll.add(new String("Tom"));        coll.add(false);        //1.contains(Object obj):判断当前集合中是否包含obj        //我们在判断时会调用obj对象所在类的equals()。        boolean contains = coll.contains(123);        System.out.println(contains);        System.out.println(coll.contains(new String("Tom")));  //        System.out.println(coll.contains(p));//true        System.out.println(coll.contains(new Person("Jerry",20)));//false --&gt;true          //2.containsAll(Collection coll1):判断形参coll1中的所有元素是否都存在于当前集合中。        Collection coll1 = Arrays.asList(123,4567);        System.out.println(coll.containsAll(coll1));    }      @Test    public void test2(){        //3.remove(Object obj):从当前集合中移除obj元素。        Collection coll = new ArrayList();        coll.add(123);        coll.add(456);        coll.add(new Person("Jerry",20));        coll.add(new String("Tom"));        coll.add(false);          coll.remove(1234);        System.out.println(coll);          coll.remove(new Person("Jerry",20));        System.out.println(coll);          //4. removeAll(Collection coll1):差集：从当前集合中移除coll1中所有的元素。        Collection coll1 = Arrays.asList(123,456);        coll.removeAll(coll1);        System.out.println(coll);```java}@Testpublic void test3(){    Collection coll = new ArrayList();    coll.add(123);    coll.add(456);    coll.add(new Person("Jerry",20));    coll.add(new String("Tom"));    coll.add(false);    //5.retainAll(Collection coll1):交集：获取当前集合和coll1集合的交集，并返回给当前集合<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>//        Collection coll1 = Arrays.asList(123,456,789);<br>//        coll.retainAll(coll1);<br>//        System.out.println(coll);</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//6.equals(Object obj):要想返回true，需要当前集合和形参集合的元素都相同。</span><span class="token class-name">Collection</span> coll1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>coll1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">456</span><span class="token punctuation">)</span><span class="token punctuation">;</span>coll1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>coll1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Jerry"</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>coll1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>coll1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>coll<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>coll1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">}</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">Collection</span> coll <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    coll<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    coll<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">456</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    coll<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Jerry"</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    coll<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    coll<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//7.hashCode():返回当前对象的哈希值</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>coll<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//8.集合 ---&gt;数组：toArray()</span>    <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> coll<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//拓展：数组 ---&gt;集合:调用Arrays类的静态方法asList()</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"AA"</span><span class="token punctuation">,</span> <span class="token string">"BB"</span><span class="token punctuation">,</span> <span class="token string">"CC"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">List</span> arr1 <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">456</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1</span>    <span class="token class-name">List</span> arr2 <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">456</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2</span>    <span class="token comment">//9.iterator():返回Iterator接口的实例，用于遍历集合元素。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">## <span class="token number">2.</span>Iterator迭代器接口<span class="token number">1.</span><span class="token operator">*</span><span class="token operator">*</span>集合元素的遍历操作，使用迭代器<span class="token class-name">Iterator</span>接口<span class="token operator">*</span><span class="token operator">*</span>  <span class="token number">1.</span>内部的方法：<span class="token operator">*</span><span class="token operator">*</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 和  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>和 remove<span class="token operator">*</span><span class="token operator">*</span>  <span class="token number">2.</span>集合对象每次调用<span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。  <span class="token number">3.</span>内部定义了<span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用<span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">2.</span><span class="token operator">*</span><span class="token operator">*</span>iterator迭代器的执行原理<span class="token operator">*</span><span class="token operator">*</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">Collection</span> coll <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        coll<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        coll<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">456</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        coll<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Jerry"</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        coll<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        coll<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Iterator</span> iterator <span class="token operator">=</span> coll<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//hasNext():判断是否还有下一个元素</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">//next():①指针下移 ②将下移以后集合位置上的元素返回</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>![image.png](图片合集/image 2.png)</p><ul><li><strong>注意</strong>：在调用it.next()方法之前必须要调用it.hasNext()进行检测。若不调用，且 下一条记录无效，直接调用it.next()会抛NoSuchElementException异常。</li></ul><p>3.Iterator接口<strong>remove()方法</strong></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Iterator iter = coll.iterator();//回到起点while(iter.hasNext()){Object obj = iter.next();if(obj.equals("Tom")){iter.remove();}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>注意： </p><p>1.Iterator可以删除集合的元素，但是是遍历过程中<strong>通过迭代器对象的remove方法</strong>，不是集合对象的remove方法。 </p><p>2.如果<strong>还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法</strong>， 再调用remove都会报<strong>IllegalStateException</strong>。</p></li></ul><p>4.使用 <strong>foreach 循环遍历集合元素(增强for循环)</strong></p><ul><li><p>关于<strong>foreach 循环</strong></p><p>1.Java 5.0 提供了 foreach 循环迭代访问 <strong>Collection和数组</strong>。 </p><p>2.遍历操作不需获取Collection或数组的长度，无需使用索引访问元素。 </p><p>3.遍历集合的<strong>底层调用Iterator</strong>完成操作。 </p><p>4.foreach还可以用来遍历数组。</p></li><li><p>格式</p></li></ul><p>![image.png](图片合集/image 3.png)</p><ul><li>代码实现</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">//遍历集合public void test1(){        Collection coll = new ArrayList();        coll.add(123);        coll.add(456);        coll.add(new Person("Jerry",20));        coll.add(new String("Tom"));        coll.add(false);        //for(集合元素的类型 局部变量 : 集合对象)        //内部仍然调用了迭代器。        for(Object obj : coll){            System.out.println(obj);        }    }//遍历数组 public void test2(){        int[] arr = new int[]{1,2,3,4,5,6};        //for(数组元素的类型 局部变量 : 数组对象)        for(int i : arr){            System.out.println(i);        }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-Collection子接口：-List接口"><a href="#3-Collection子接口：-List接口" class="headerlink" title="3.Collection子接口： List接口"></a>3.Collection子接口： List接口</h2><p><strong>1.List接口框架</strong></p><p>  |—-Collection接口：<strong>单列集合，用来存储一个一个的对象</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token class-name">List</span>接口：<span class="token operator">*</span><span class="token operator">*</span>存储有序的、可重复的数据<span class="token operator">*</span><span class="token operator">*</span>。  <span class="token operator">--</span><span class="token operator">&gt;</span>“动态”数组<span class="token punctuation">,</span>替换原有的数组  <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token class-name">ArrayList</span>：作为<span class="token class-name">List</span>接口的主要实现类；线<span class="token operator">*</span><span class="token operator">*</span>程不安全的，效率高<span class="token operator">*</span><span class="token operator">*</span>；底层使用<span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elementData（<span class="token operator">*</span><span class="token operator">*</span>数组<span class="token operator">*</span><span class="token operator">*</span>）存储  <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token class-name">LinkedList</span>：对于<span class="token operator">*</span><span class="token operator">*</span>频繁的插入、删除操作，使用此类效率比<span class="token class-name">ArrayList</span>高<span class="token operator">*</span><span class="token operator">*</span>；底层使用<span class="token operator">*</span><span class="token operator">*</span>双向链表<span class="token operator">*</span><span class="token operator">*</span>存储  <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token class-name">Vector</span>：作为<span class="token class-name">List</span>接口的古老实现类；<span class="token operator">*</span><span class="token operator">*</span>线程安全的，效率低<span class="token operator">*</span><span class="token operator">*</span>；底层使用<span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elementData（<span class="token operator">*</span><span class="token operator">*</span>数组<span class="token operator">*</span><span class="token operator">*</span>）存储<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li></li></ul><p><strong>2.ArrayList的源码分析</strong>：</p><p>  2.1 <strong>jdk 7情况下</strong></p><p>  ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData</p><p>  list.add(123);//elementData[0] = new Integer(123);</p><p>  …</p><p>  list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。</p><p>  <strong>默认情况下，扩容为原来的容量的1.5倍</strong>，同时需要将原有数组中的数据复制到新的数组中。</p><p>  结论：<strong>建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)</strong></p><p>  2.2 <strong>jdk 8中ArrayList的变化</strong>：</p><p>  ArrayList list = new ArrayList();//底层Object[] elementData初始化为{}.并没有创建长度为10的数组</p><p>  list.add(123);//<strong>第一次调用add()时，底层才创建了长度10的数组</strong>，并将数据123添加到elementData[0]</p><p>  …</p><p>  后续的添加和扩容操作与jdk 7 无异。</p><p>  2.3 小结：<strong>jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存</strong>。</p><blockquote></blockquote><p><strong>3.LinkedList的源码分析</strong>：</p><p>  LinkedList list = new LinkedList(); 内部声明了<strong>Node类型的first和last属性</strong>，默认值为null</p><p>  list.add(123);//将123封装到Node中，创建了Node对象。</p><p>  其中，Node定义为：<strong>体现了LinkedList的双向链表的说法</strong></p><ul><li><p>双向链表底层代码实现</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">      private static class Node&lt;E&gt; {      E item;      Node&lt;E&gt; next;      Node&lt;E&gt; prev;          Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {      this.item = element;      this.next = next;      this.prev = prev;      }    }```java**4.Vector的源码分析：**  jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。在扩容方面，默认扩容为原来的数组长度的2倍。**面试题：**ArrayList、LinkedList、Vector三者的异同？  同：三个类**都是实现了List接口**，存储数据的特点相同：**存储有序的、可重复的数据**  - 不同：    |----ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储    |----LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储    |----Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储5.List接口中的常用方法  **void add(int index, Object ele)**:在index位置插入ele元素boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来**Object get(int index)**:获取指定index位置的元素int indexOf(Object obj):返回obj在集合中首次出现的位置int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置**Object remove(int index)**:移除指定index位置的元素，并返回此元素**Object set(int index, Object ele**):设置指定index位置的元素为eleList subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合- 总结：常用方法**增**：add(Object obj)**删**：remove(int index) / remove(Object obj)**改**：set(int index, Object ele)**查**：get(int index)**插**：add(int index, Object ele)**长度**：size()**遍历**：  ① Iterator迭代器方式② 增强for循环③ 普通的循环## 4.Collection子接口： Set接口1. **Set接口的框架：**  |----Collection接口：**单列集合，用来存储一个一个的对象**    |----Set接口：**存储无序的、不可重复的数据**   --&gt;高中讲的“集合”      |----HashSet：作为Set接口的主要实现类；**线程不安全的；可以存储null值**        |----LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历,**对于频繁的遍历操作，LinkedHashSet效率高于HashSet.**      |----TreeSet：**可以按照添加对象的指定属性，进行排序**。2.Set接口中没有额外定义新的方法，使用的都是Collection中声明过的方法。**3.关于Set举例HashSet：**一、**存储无序的、不可重复的数据**以HashSet为例说明：  1. **无序性**：**不等于随机性**。存储的数据在底层数组中并非按照数组索引的顺序添加，而是**根据数据的哈希值决定的**。  2.**不可重复性**：保证添加的元素按照equals()判断时，不能返回true.即：**相同的元素只能添加一个。**二、添加元素的过程：以HashSet为例：  我们向HashSet中添加元素a,首先调用元素a所在类的**hashCode()方法**，计算元素a的**哈希值**，此哈希值接着通过某种算法计算出在**HashSet底层数组中的存放位置**（即为：**索引位置**），判断数组此位置上是**否已经有元素**：  如果此位置上没有其他元素，则元素a添加成功。 ---**&gt;情况1**如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值：    如果hash值不相同，则元素a添加成功。---**&gt;情况2**如果hash值相同，进而需要调用元素a所在类的equals()方法：      equals()返回true,元素a添加失败equals()返回false,则元素a添加成功。---**&gt;情况3**  对于添加成功的**情况2和情况3**而言：**元素a 与已经存在指定索引位置上数据以链表的方式存储**。jdk 7 :元素a放到数组中，指向原来的元素。jdk 8 :原来的元素在数组中，指向元素a总结：**七上八下**  HashSet底层：**数组+链表的结构**。HashSet实现图示：- 要求：  1.向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类**一定要重写hashCode()和equals()**  2.**重写的hashCode()和equals()尽可能保持一致性**：**相等的对象必须具有相等的散列码（hashCode）**- 重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。**4.LinkedHashSet的使用**  LinkedHashSet作为HashSet的子类，在添加数据的同时，**每个数据还维护了两个引用**，记录此数据前一个数据和后一个数据。优点：**对于频繁的遍历操作，LinkedHashSet效率高于HashSet**- 关于**LinkedHashSet**  1.LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置， 但它同时使用双向链表维护元素的次序，这使得元素看起来是以**插入顺序**保存的。   2.LinkedHashSet**插入性能略低于 HashSet**，但在**迭代访问 Set 里的全部元素时有很好的性能。**   3.LinkedHashSet 不允许集合元素重复。- LinkedHashSet实现图示：**5.Set实现类之三：TreeSet**1.向TreeSet中添加的数据，要求是**相同类的对象**。- 因为只有相同类的两个实例才会比较大小，所以向 **TreeSet 中添加的应该是同 一个类的对象。**- 代码测试  ```Javapublic void test1(){        TreeSet set = new TreeSet();        //失败：不能添加不同类的对象//        set.add(123);//        set.add(456);//        set.add("AA");//        set.add(new User("Tom",12));            //举例一：//        set.add(34);//        set.add(-34);//        set.add(43);//        set.add(11);//        set.add(8);        //举例二：        set.add(new User("Tom",12));        set.add(new User("Jerry",32));        set.add(new User("Jim",2));        set.add(new User("Mike",65));        set.add(new User("Jack",33));        set.add(new User("Jack",56));        Iterator iterator = set.iterator();        while(iterator.hasNext()){            System.out.println(iterator.next());        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>![image.png](图片合集/image 4.png)</p><p>![image.png](图片合集/image 5.png)</p><p>2.两种排序方式：<strong>自然排序（实现Comparable接口）</strong> 和 <strong>定制排序（Comparator）</strong></p><ul><li>自然排序（实现Comparable接口）</li></ul><p>  见Comparable章节（<strong>重写comparTo方法</strong>）</p><ul><li><p>定制排序（Comparator）</p></li><li><p>代码测试</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">    public void test2(){        Comparator com = new Comparator() {            //按照年龄从小到大排列            @Override            public int compare(Object o1, Object o2) {                if(o1 instanceof User &amp;&amp; o2 instanceof User){                    User u1 = (User)o1;                    User u2 = (User)o2;                    return Integer.compare(u1.getAge(),u2.getAge());                }else{                    throw new RuntimeException("输入的数据类型不匹配");                }            }        };            TreeSet set = new TreeSet(com);        set.add(new User("Tom",12));        set.add(new User("Jerry",32));        set.add(new User("Jim",2));        set.add(new User("Mike",65));        set.add(new User("Mary",33));        set.add(new User("Jack",33));        set.add(new User("Jack",56));```java    Iterator iterator = set.iterator();    while(iterator.hasNext()){        System.out.println(iterator.next());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>![image.png](图片合集/image 6.png)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">3.</span>自然排序中，比较两个对象是否相同的标准为：<span class="token operator">*</span><span class="token operator">*</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>返回<span class="token number">0.</span>不再是<span class="token function">equals</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>*<span class="token operator">*</span><span class="token number">4.</span>定制排序中，比较两个对象是否相同的标准为：<span class="token operator">*</span><span class="token operator">*</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token punctuation">)</span>返回<span class="token number">0.</span>不再是<span class="token function">equals</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>*<span class="token operator">*</span><span class="token operator">-</span> <span class="token class-name">TreeSet</span>底层使用<span class="token operator">*</span><span class="token operator">*</span>红黑树<span class="token operator">*</span><span class="token operator">*</span>结构存储数据# <span class="token number">2.</span>Map接口<span class="token operator">*</span><span class="token operator">*</span>一、<span class="token class-name">Map</span>的实现类的结构：<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">*</span><span class="token operator">*</span><span class="token class-name">Map</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">:</span><span class="token operator">*</span><span class="token operator">*</span>双列数据<span class="token operator">*</span><span class="token operator">*</span>，存储<span class="token operator">*</span><span class="token operator">*</span>key<span class="token operator">-</span>value<span class="token operator">*</span><span class="token operator">*</span>对的数据   <span class="token operator">--</span><span class="token operator">-</span>类似于高中的函数：y <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">*</span><span class="token operator">*</span><span class="token class-name">HashMap</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">:</span>作为<span class="token class-name">Map</span>的<span class="token operator">*</span><span class="token operator">*</span>主要实现类<span class="token operator">*</span><span class="token operator">*</span>；<span class="token operator">*</span><span class="token operator">*</span>线程不安全的，效率高<span class="token operator">*</span><span class="token operator">*</span>；存储<span class="token keyword">null</span>的key和value    <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">*</span><span class="token operator">*</span><span class="token class-name">LinkedHashMap</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">:</span>保证在遍历map元素时，可以按照<span class="token operator">*</span><span class="token operator">*</span>添加的顺序实现遍历<span class="token operator">*</span><span class="token operator">*</span>。    原因：在原有的<span class="token class-name">HashMap</span>底层结构基础上，<span class="token operator">*</span><span class="token operator">*</span>添加了一对指针，指向前一个和后一个元素。<span class="token operator">*</span><span class="token operator">*</span>    对于频繁的遍历操作，此类执行效率高于<span class="token class-name">HashMap</span>。  <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">*</span><span class="token operator">*</span><span class="token class-name">TreeMap</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">:</span>保证按照添加的key<span class="token operator">-</span>value对进行排序，实现排序遍历  <span class="token operator">*</span><span class="token operator">*</span>底层使用红黑树<span class="token operator">*</span><span class="token operator">*</span>  <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">*</span><span class="token operator">*</span><span class="token class-name">Hashtable</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">:</span>作为古老的实现类；<span class="token operator">*</span><span class="token operator">*</span>线程安全的，效率低<span class="token operator">*</span><span class="token operator">*</span>；<span class="token operator">*</span><span class="token operator">*</span>不能存储<span class="token keyword">null</span><span class="token operator">*</span><span class="token operator">*</span>的key和value    <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token class-name">Properties</span><span class="token operator">:</span>常用来处理配置文件。key和value都是<span class="token operator">*</span><span class="token operator">*</span><span class="token class-name">String</span>类<span class="token operator">*</span><span class="token operator">*</span><span class="token class-name">HashMap</span>的底层：  <span class="token operator">*</span><span class="token operator">*</span>数组<span class="token operator">+</span>链表<span class="token operator">*</span><span class="token operator">*</span>  （jdk7及之前）  <span class="token operator">*</span><span class="token operator">*</span>数组<span class="token operator">+</span>链表<span class="token operator">+</span>红黑树<span class="token operator">*</span><span class="token operator">*</span> （jdk <span class="token number">8</span>）面试题：<span class="token number">1.</span> <span class="token class-name">HashMap</span>的底层实现原理？  见下，三<span class="token number">1.</span> <span class="token class-name">HashMap</span> 和 <span class="token class-name">Hashtable</span>的异同？  <span class="token operator">*</span><span class="token operator">*</span><span class="token class-name">HashMap</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">:</span>作为<span class="token class-name">Map</span>的主要实现类；<span class="token operator">*</span><span class="token operator">*</span>线程不安全的，效率高<span class="token operator">*</span><span class="token operator">*</span>；存储<span class="token keyword">null</span>的key和value  <span class="token operator">*</span><span class="token operator">*</span><span class="token class-name">Hashtable</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">:</span>作为古老的实现类；<span class="token operator">*</span><span class="token operator">*</span>线程安全的，效率低<span class="token operator">*</span><span class="token operator">*</span>；<span class="token operator">*</span><span class="token operator">*</span>不能存储<span class="token keyword">null</span><span class="token operator">*</span><span class="token operator">*</span>的key和value<span class="token number">1.</span> <span class="token class-name">CurrentHashMap</span> 与 <span class="token class-name">Hashtable</span>的异同？（暂时不讲）## <span class="token number">1.</span>HashMap（重点）<span class="token operator">*</span><span class="token operator">*</span><span class="token number">1.</span>结构的理解：<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">-</span> <span class="token class-name">Map</span>中的<span class="token operator">*</span><span class="token operator">*</span>key<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">:</span><span class="token operator">*</span><span class="token operator">*</span>无序的、不可重复的<span class="token operator">*</span><span class="token operator">*</span>，使用<span class="token operator">*</span><span class="token operator">*</span><span class="token class-name">Set</span><span class="token operator">*</span><span class="token operator">*</span>存储所有的key  <span class="token operator">--</span><span class="token operator">-&gt;</span> key所在的类<span class="token operator">*</span><span class="token operator">*</span>要重写<span class="token function">equals</span><span class="token punctuation">(</span><span class="token punctuation">)</span>和<span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">*</span> （以<span class="token class-name">HashMap</span>为例）<span class="token operator">-</span> <span class="token class-name">Map</span>中的<span class="token operator">*</span><span class="token operator">*</span>value<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">:</span><span class="token operator">*</span><span class="token operator">*</span>无序的、可重复的<span class="token operator">*</span><span class="token operator">*</span>，使用<span class="token operator">*</span><span class="token operator">*</span><span class="token class-name">Collection</span><span class="token operator">*</span><span class="token operator">*</span>存储所有的value <span class="token operator">--</span><span class="token operator">-&gt;</span>value所在的类<span class="token operator">*</span><span class="token operator">*</span>要重写<span class="token function">equals</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">-</span> 一个键值对：key<span class="token operator">-</span>value构成了一个<span class="token operator">*</span><span class="token operator">*</span><span class="token class-name">Entry</span><span class="token operator">*</span><span class="token operator">*</span>对象。      <span class="token class-name">Map</span>中的entry<span class="token operator">:</span><span class="token operator">*</span><span class="token operator">*</span>无序的、不可重复的<span class="token operator">*</span><span class="token operator">*</span>，使用<span class="token operator">*</span><span class="token operator">*</span><span class="token class-name">Set</span><span class="token operator">*</span><span class="token operator">*</span>存储所有的entry<span class="token operator">-</span> 图示：<span class="token operator">*</span><span class="token operator">*</span><span class="token number">2.</span>HashMap的底层实现原理？<span class="token operator">*</span><span class="token operator">*</span>以jdk7为例说明：<span class="token class-name">HashMap</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token operator">*</span><span class="token operator">*</span>在实例化以后，底层创建了长度是<span class="token number">16</span>的一维数组<span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> table。（jdk7）<span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>可能已经执行过多次put<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key1<span class="token punctuation">,</span>value1<span class="token punctuation">)</span><span class="token operator">:</span>首先，调用key1所在类的<span class="token operator">*</span><span class="token operator">*</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>计算key1哈希值<span class="token operator">*</span><span class="token operator">*</span>，此哈希值经过某种算法计算以后，<span class="token operator">*</span><span class="token operator">*</span>得到在<span class="token class-name">Entry</span>数组中的存放位置<span class="token operator">*</span><span class="token operator">*</span>。如果此位置上的数据为空，此时的key1<span class="token operator">-</span>value1添加成功。 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">*</span><span class="token operator">*</span>情况<span class="token number">1</span><span class="token operator">*</span><span class="token operator">*</span>如果此位置上的数据不为空，<span class="token punctuation">(</span>意味着此位置上存在一个或多个数据<span class="token punctuation">(</span>以链表形式存在<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>比较<span class="token operator">*</span><span class="token operator">*</span>key1和已经存在的一个或多个数据的哈希值<span class="token operator">*</span><span class="token operator">*</span>：  如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1<span class="token operator">-</span>value1添加成功。（<span class="token operator">*</span><span class="token operator">*</span>添加在第一个位置jdk7<span class="token operator">*</span><span class="token operator">*</span>）<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">*</span><span class="token operator">*</span>情况<span class="token number">2</span><span class="token operator">*</span><span class="token operator">*</span>  如果key1的哈希值和已经存在的某一个数据<span class="token punctuation">(</span>key2<span class="token operator">-</span>value2<span class="token punctuation">)</span>的哈希值相同，继续比较：调用<span class="token operator">*</span><span class="token operator">*</span>key1所在类的<span class="token function">equals</span><span class="token punctuation">(</span>key2<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">*</span>方法，比较：    如果<span class="token function">equals</span><span class="token punctuation">(</span><span class="token punctuation">)</span>返回<span class="token boolean">false</span><span class="token operator">:</span>此时key1<span class="token operator">-</span>value1<span class="token operator">*</span><span class="token operator">*</span>添加成功<span class="token operator">*</span><span class="token operator">*</span>（<span class="token operator">*</span><span class="token operator">*</span>添加在第一个位置jdk7<span class="token operator">*</span><span class="token operator">*</span>）。<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">*</span><span class="token operator">*</span>情况<span class="token number">3</span><span class="token operator">*</span><span class="token operator">*</span>    <span class="token operator">*</span><span class="token operator">*</span>如果<span class="token function">equals</span><span class="token punctuation">(</span><span class="token punctuation">)</span>返回<span class="token boolean">true</span><span class="token operator">:</span>使用value1替换value2（覆盖）<span class="token operator">*</span><span class="token operator">*</span>。补充：关于<span class="token operator">*</span><span class="token operator">*</span>情况<span class="token number">2</span>和情况<span class="token number">3</span><span class="token operator">*</span><span class="token operator">*</span>：此时key1<span class="token operator">-</span>value1和原来的数据<span class="token operator">*</span><span class="token operator">*</span>以链表的方式存储。<span class="token operator">*</span><span class="token operator">*</span>在不断的添加过程中，会涉及到扩容问题，当超出<span class="token operator">*</span><span class="token operator">*</span>临界值<span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">(</span>且要存放的位置非空<span class="token punctuation">)</span>时，扩容。默认的扩容方式：扩容为<span class="token operator">*</span><span class="token operator">*</span>原来容量的<span class="token number">2</span>倍<span class="token operator">*</span><span class="token operator">*</span>，<span class="token operator">*</span><span class="token operator">*</span>并将原有的数据复制过来。<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">-</span> <span class="token operator">*</span><span class="token operator">*</span>jdk7HashMap实现原理图示<span class="token operator">*</span><span class="token operator">*</span>：<span class="token operator">-</span> <span class="token operator">*</span><span class="token operator">*</span>jdk8 相较于jdk7在底层实现方面的不同<span class="token operator">*</span><span class="token operator">*</span>：  <span class="token number">1.</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>底层<span class="token operator">*</span><span class="token operator">*</span>没有创建一个长度为<span class="token number">16</span>的数组<span class="token operator">*</span><span class="token operator">*</span>  <span class="token number">2.</span> jdk <span class="token number">8</span>底层的数组是：<span class="token class-name">Node</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>而非<span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token number">3.</span> <span class="token operator">*</span><span class="token operator">*</span>首次调用<span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法时<span class="token operator">*</span><span class="token operator">*</span>，<span class="token operator">*</span><span class="token operator">*</span>底层创建长度为<span class="token number">16</span>的数组（类似懒汉式）<span class="token operator">*</span><span class="token operator">*</span>  <span class="token number">4.</span> jdk7底层结构只有：数组<span class="token operator">+</span>链表。jdk8中底层结构：<span class="token operator">*</span><span class="token operator">*</span>数组<span class="token operator">+</span>链表<span class="token operator">+</span>红黑树。<span class="token operator">*</span><span class="token operator">*</span>    <span class="token number">4.1</span> 形成链表时，<span class="token operator">*</span><span class="token operator">*</span>七上八下<span class="token operator">*</span><span class="token operator">*</span>（<span class="token operator">*</span><span class="token operator">*</span>jdk7<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">:</span>新的元素指向旧的元素。<span class="token operator">*</span><span class="token operator">*</span>jdk8<span class="token operator">*</span><span class="token operator">*</span>：旧的元素指向新的元素）<span class="token number">4.2</span> 当数组的某一个索引位置上的元素以链表形式存在的数据个数 <span class="token operator">*</span><span class="token operator">*</span>（链长）<span class="token operator">&gt;</span> <span class="token number">8</span><span class="token operator">*</span><span class="token operator">*</span> 且<span class="token operator">*</span><span class="token operator">*</span>当前数组的长度 <span class="token operator">&gt;</span> <span class="token number">64</span>时<span class="token operator">*</span><span class="token operator">*</span>，此时此索引位置上的所数据<span class="token operator">*</span><span class="token operator">*</span>改为使用红黑树存储<span class="token operator">*</span><span class="token operator">*</span>。<span class="token operator">-</span> <span class="token operator">*</span><span class="token operator">*</span>jdk8HashMap实现原理图示<span class="token operator">*</span><span class="token operator">*</span>：<span class="token operator">-</span> 一些专业名词  <span class="token constant">DEFAULT_INITIAL_CAPACITY</span> <span class="token operator">:</span> <span class="token class-name">HashMap</span>的默认容量，<span class="token number">16</span>  <span class="token constant">DEFAULT_LOAD_FACTOR</span>：<span class="token class-name">HashMap</span>的<span class="token operator">*</span><span class="token operator">*</span>默认加载因子<span class="token operator">*</span><span class="token operator">*</span>：<span class="token number">0.75</span>  threshold：<span class="token operator">*</span><span class="token operator">*</span>扩容的临界值<span class="token operator">*</span><span class="token operator">*</span>，<span class="token operator">=</span><span class="token operator">*</span><span class="token operator">*</span>容量<span class="token operator">*</span>填充（加载）因子<span class="token operator">*</span><span class="token operator">*</span>：<span class="token number">16</span> <span class="token operator">*</span> <span class="token number">0.75</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">12</span>  <span class="token constant">TREEIFY_THRESHOLD</span>：<span class="token class-name">Bucket</span>中<span class="token operator">*</span><span class="token operator">*</span>链表长度<span class="token operator">*</span><span class="token operator">*</span>大于该默认值，转化为红黑树<span class="token operator">:</span><span class="token number">8</span>  <span class="token constant">MIN_TREEIFY_CAPACITY</span>：<span class="token operator">*</span><span class="token operator">*</span>桶中的<span class="token class-name">Node</span>被树化时最小的hash表容量<span class="token operator">:</span><span class="token number">64</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token number">3.</span>子类<span class="token class-name">LinkedHashMap</span>底层实现原理（了解）<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">-</span> 与<span class="token class-name">LinkedHashSet</span>类似，<span class="token class-name">LinkedHashMap</span> 可以<span class="token operator">*</span><span class="token operator">*</span>维护 <span class="token class-name">Map</span>的迭代顺序<span class="token operator">*</span><span class="token operator">*</span>：迭代顺序与 <span class="token class-name">Key</span><span class="token operator">-</span><span class="token class-name">Value</span> 对的插入顺序一致源码中：```<span class="token class-name">Java</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>      <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> before<span class="token punctuation">,</span> after<span class="token punctuation">;</span><span class="token comment">//能够记录添加的元素的先后顺序</span>      <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>![image.png](图片合集/image 7.png)</p><p>![image.png](图片合集/image 8.png)</p><p>![image.png](图片合集/image 9.png)</p><p>五、Map中定义的方法：<br>添加、删除、修改操作：</p><p>  <strong>Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中</strong><br>void putAll(Map m):将m中的所有key-value对存放到当前map中<br><strong>Object remove(Object key)：移除指定key的key-value对，并返回value</strong><br>void clear()：清空当前map中的所有数据</p><p>元素查询的操作：</p><p>  <strong>Object get(Object key)：获取指定key对应的value</strong><br>boolean containsKey(Object key)：是否包含指定的key<br>boolean containsValue(Object value)：是否包含指定的value<br><strong>int size()：返回map中key-value对的个数</strong><br>boolean isEmpty()：判断当前map是否为空<br>boolean equals(Object obj)：判断当前map和参数对象obj是否相等</p><p>元视图操作的方法：</p><p>  <strong>Set keySet()：返回所有key构成的Set集合</strong><br><strong>Collection values()：返回所有value构成的Collection集合<br>Set entrySet()：返回所有key-value对构成的Set集合</strong></p><p>总结：常用方法：</p><ul><li><p>添加：<strong>put(Object key,Object value)</strong></p></li><li><p>删除：<strong>remove(Object key)</strong></p></li><li><p>修改：<strong>put(Object key,Object value)</strong></p></li><li><p>查询：<strong>get(Object key)</strong></p></li><li><p>长度：<strong>size()</strong></p></li><li><p>遍历：<strong>keySet() / values() / entrySet()</strong></p></li></ul><h2 id="2-TreeMap（了解）"><a href="#2-TreeMap（了解）" class="headerlink" title="2.TreeMap（了解）"></a>2.TreeMap（了解）</h2><p>1.向TreeMap中添加key-value，要求key<strong>必须是由同一个类创建的对象</strong></p><p>2.TreeMap存储 Key-Value 对时，需要根据 key-value 对进行排序。 TreeMap 可以保证所有的 Key-Value 对处于有序状态。 </p><p>3.TreeSet底层使用<strong>红黑树结构存</strong>储数据 </p><p>4.TreeMap 的 Key 的排序：</p><p>  自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有 的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException </p><p>  定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现 Comparable 接口 </p><p>5.TreeMap判断两个key相等的标准：两个key通过compareTo()方法或 者compare()方法返回0。</p><h2 id="3-Hashtable-了解"><a href="#3-Hashtable-了解" class="headerlink" title="3.Hashtable(了解)"></a>3.Hashtable(了解)</h2><ul><li><p> Hashtable是个古老的 Map 实现类，JDK1.0就提供了。不同于HashMap， Hashtable是线程安全的。 </p></li><li><p> Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询 速度快，很多情况下可以互用。 </p></li><li><p> 与HashMap不同，Hashtable 不允许使用 null 作为 key 和 value </p></li><li><p> 与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序 </p></li><li><p> Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。</p></li></ul><h2 id="4-Properties-了解"><a href="#4-Properties-了解" class="headerlink" title="4.Properties(了解)"></a>4.Properties(了解)</h2><ul><li><p>Properties 类是 <strong>Hashtable 的子类</strong>，该对象用于<strong>处理属性文件</strong></p></li><li><p>由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 <strong>key 和 value 都是字符串类型</strong></p></li><li><p>存取数据时，建议使用setProperty(String key,String value)方法和 getProperty(String key)方法</p></li></ul><p>代码示例：</p><p>![image.png](图片合集/image 10.png)</p><h2 id="5-Collections工具类"><a href="#5-Collections工具类" class="headerlink" title="5.Collections工具类"></a>5.Collections工具类</h2><ul><li>Collections:操作<strong>Collection、Map的工具类</strong></li></ul><ul><li><p>面试题：Collection 和 Collections的区别？</p><p>答：Collection是储存单列数据的集合接口，有list，set，v子接口，定义了两种不同的储存方式。</p><p>Collections包含很多有关操作集合静态方法，不能实例化，Collections是工具类，服务于集合框架。</p></li></ul><ul><li><p>常用方法：</p><p>reverse(List)：反转 List 中元素的顺序<br>shuffle(List)：对 List 集合元素进行随机排序<br>sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序<br>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序<br>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</p><p>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素<br>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素<br>Object min(Collection)<br>Object min(Collection，Comparator)<br>int frequency(Collection，Object)：返回指定集合中指定元素的出现次数<br>void copy(List dest,List src)：将src中的内容复制到dest中<br>boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</p></li></ul><p>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集 合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全 问题</p><ul><li><p>示例：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">  //返回的list1即为线程安全的List        List list1 = Collections.synchronizedList(list);```java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人简历</title>
      <link href="/2023/05/04/bgk-shi-xi-jian-li-jian-li-zui-zhong-ban-3.0/"/>
      <url>/2023/05/04/bgk-shi-xi-jian-li-jian-li-zui-zhong-ban-3.0/</url>
      
        <content type="html"><![CDATA[<h1 id="班-后端工程师（实习）"><a href="#班-后端工程师（实习）" class="headerlink" title="班**-后端工程师（实习）"></a>班**-后端工程师（实习）</h1><p> 男/2001.05  </p><p>电话：xxxxxxxxxxx</p><p>微信：XueFeiyang_O_o</p><p>邮箱：<a href="mailto:feiyangxu88@gmail.com">feiyangxu88@gmail.com</a></p><h2 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h2><p><strong>xxxx大学 - xx系统</strong><br><strong>2020.09 - 2024.06</strong><br>相关课程：java程序设计、数据库原理、计算机网络、数据结构</p><h2 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h2><ul><li>熟悉Java基础知识（<strong>集合，IO</strong>等），了解JUC并发编程（<strong>线程池，AQS</strong>等），JVM虚拟机理论知识（<strong>类加载，GC</strong>等）。</li><li>掌握计算机网络理论知识（<strong>TCP/IP</strong>、 <strong>HTTP等协议</strong>），操作系统（<strong>进程，内存</strong>等）。</li><li>熟悉<strong>Mysql、Redis</strong>等数据库，了解其相关原理及常见的优化手段。</li><li>熟悉<strong>Spring、<a href="https://so.csdn.net/so/search?q=Springmvc&amp;spm=1001.2101.3001.7020">Springmvc</a>、MyBatis，SpringBoot</strong>等主流开发框架。</li><li>了解<strong>SpringCloud、Elasticsearch ,  Nacos、Feign、gateway</strong>等分布式组件的应用。</li><li>了解<strong>Linux</strong>常用命令，了解 <strong>Docker，Git、Maven</strong>等工具的基本使用。</li></ul><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><h3 id="剧本杀-线上平台"><a href="#剧本杀-线上平台" class="headerlink" title="剧本杀-线上平台"></a><strong><strong>剧本杀-线上平台</strong></strong></h3><p><strong>2022.09 - 2022.10</strong></p><p><code>SpringBoot</code> <code>Redis</code> <code>MybatisPuls</code> <code>Nginx</code> <code>Vue</code></p><ul><li><p><strong>项目描述：</strong></p><p>剧本杀-线上平台是为区域内的线下剧本杀店铺的点评平台，为用户提供店铺点评，剧本优惠券购买，最近店铺等功能。</p></li><li><p><strong>工作内容：</strong></p><ul><li><p><strong>手机号登录</strong>：基于<strong>阿里云短信服务</strong>，<strong>Redis</strong>实现登录功能。</p></li><li><p><strong>剧本杀店铺缓存</strong>：基于<strong>Redis</strong>缓存店铺信息，同时解决<strong>缓存击穿，缓存穿透</strong>等问题。</p></li><li><p><strong>剧本购买优惠券及优化</strong>：基于<strong>Redis</strong>实现优惠券秒杀及其优化（<strong>一人一单</strong>，<strong>超卖问题</strong>，<strong>分步式锁</strong>，<strong>异步下单</strong>）。</p></li><li><p><strong>附近店铺</strong>：<strong>GEO</strong>实现附近店铺排序展示。</p></li></ul></li><li><p><strong>项目难点：</strong> </p><p>理解并根据实际情况应用Redis底层数据结构和相关特性解决实际问题</p></li></ul><h3 id="医民通"><a href="#医民通" class="headerlink" title="医民通"></a>医民通</h3><p><strong>2022.11 - 2023.1</strong></p><p><code>SpringBoot</code> <code>SpringCould</code> <code>Redis</code> <code>MongoDB</code> <code>Vue</code></p><ul><li><p><strong>项目描述</strong>：<br>医民通是一个完整的医院预约挂号微服务系统。主要功能是为民众提供网上预约挂号功能，从根本上解决看病难，挂号难这一就医难题。包含后台管理系统和前台用户系统，采用前后端分离开发模式。</p></li><li><p><strong>工作内容</strong>：</p><ul><li><strong>数据字典</strong>：通过 <strong>Redis</strong> 实现数据字典的缓存，提高查询效率。</li><li><strong>微服务架构</strong>：基于SpringCloud中的<strong>Feign</strong>组件实现远程调用, <strong>Gateway</strong> 配置网关，<strong>Nacos</strong>作为注册中心与服务调用。</li><li><strong>消息队列</strong>：使用<strong>RabbitMQ</strong>消息队列，发送目前消息，实现异步下单。</li><li><strong>主要第三方API</strong>：阿里云短信，微信授权二维码登录，阿里云OSS云储存。</li><li>应用了<strong>Mongdb</strong>数据库存储大量后台数据。</li><li>通过 <strong>EasyExcel</strong> 实现数据字典的导入导出。</li></ul></li><li><p><strong>项目难点：</strong></p><p> 微服务各组件的应用与整合，理解各个模块之间的联系。</p></li></ul><h2 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h2><ul><li><p>热爱编程，喜欢思考，能查阅各种开发技术的中英文手册，具有独立解决问题的能力；具有良好的开发能力。</p></li><li><p>自学java，有自制力，做事有始有终；学习能力强，愿意不断地接触学习新知识。</p></li><li><p>担任过学生干部，工作中吃苦耐劳，尽职尽责，适应力强；在团队中，善于与人沟通，有良好的协调能力。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>demo</title>
      <link href="/2023/05/04/demo/"/>
      <url>/2023/05/04/demo/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>徐飞扬SPACE</title>
      <link href="/2023/05/04/xu-fei-yang-space/"/>
      <url>/2023/05/04/xu-fei-yang-space/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/05/04/hello-world/"/>
      <url>/2023/05/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
